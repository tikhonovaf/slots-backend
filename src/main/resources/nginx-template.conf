#user  nobody;
#worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
  lua_shared_dict my_limit_req_store 1000m;
  lua_shared_dict my_limit_count_store 1000m;
  lua_shared_dict prometheus_metrics 1000M;
  lua_shared_dict uri_by_host 100M;
  lua_shared_dict global_set 100M;
  
  lua_package_path "/usr/local/openresty/nginx/conf/lua/?.lua;;";

  init_worker_by_lua_block {
      redis = require("resty.redis")
      limiter = require("limiters")
      limiter.init()
      prometheus = require("prometheus").init("prometheus_metrics")
      metric_requests = prometheus:counter(
          "nginx_http_requests_total", "Number of HTTP requests", {"bucket", "status", "access_key", "method"})
      metric_connections = prometheus:gauge(
        "nginx_http_connections", "Number of HTTP connections", {"state"})
      metric_bytes = prometheus:counter(
        "nginx_http_request_size_bytes", "Total size of incoming requests", {"bucket"})
      metric_response_sizes = prometheus:histogram(
        "nginx_http_response_size_bytes", "Size of HTTP responses", nil,
        {10,100,1000,10000,100000,1000000})

      -- Not used metrics
      -- metric_latency_new = prometheus:histogram("nginx_http_request_duration_seconds", "HTTP request latency status(new)", {"bucket", "status", "access_key", "method"})
      -- metric_requests = prometheus:counter(
      --    "nginx_http_requests_total", "Number of HTTP requests", {"host", "status"})
      -- metric_latency = prometheus:histogram(
      --    "nginx_http_request_duration_seconds", "HTTP request latency", {"host"})

  }

###DOWNSTREAM SERVERS START###
###DOWNSTREAM SERVERS END###

    client_max_body_size 5G;
#    client_max_body_size 0;  #unlimited
    large_client_header_buffers 8 64k;


    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    log_format upstream_logging '[$time_local] $remote_addr - $remote_user - $server_name to: $upstream_addr: $request upstream_response_time $upstream_response_time msec $msec request_time $request_time '
                                'simple_uri: $uri'
                                'status $status bytes_send $body_bytes_sent "$http_referer" $request_length'
                                'resp_header $resp_header req_header $req_header'
                                'req_body:"$request_body" resp_body:"$resp_body"';

    log_format logger-json escape=json '{"localtime": "$time_local", "time": $msec, "server_name": "$server_name", "resp_body_size": $body_bytes_sent, '
                                       '"host": "$http_host", "address": "$remote_addr", "request_length": $request_length, '
                                       '"method": "$request_method", "bucket": "$bucket", "access_key": "$access_key", "status": $status, '
                                       '"uri": "$request_uri", "user_agent": "$http_user_agent", "resp_time": $request_time, '
                                       '"s3method": "$s3method", "s3args": "$s3args", '
                                       '"upstream_addr": "$upstream_addr", "upstream_response_time": $upstream_response_time, '
                                       '"http_referer": "$http_referer", "resp_header": "$resp_header", "req_header": "$req_header", '
                                       '"req_body": "$request_body", "resp_body": "$resp_body", "http_x_forwarded_for": "$http_x_forwarded_for" '
                                       '}';

    sendfile        on;

    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  _;

        #charset koi8-r;

  set $req_header "";
  set $resp_header "";
  set $access_key "";
  set $bucket "";
  set $s3args "";
  set $s3method "";
  header_filter_by_lua '
    local h = ngx.req.get_headers()

    -- Parser bucket anme
    for word in string.gmatch(ngx.var.request_uri,"/([%a,%d,--,_]+)") do ngx.var.bucket = word break end
    -- ngx.var.bucket = ngx.var.realpath_root

    -- Parser access key
    for k, v in pairs(h) do
      ngx.var.req_header = ngx.var.req_header .. k.."="..v.." "
      if k == "authorization" then
        -- ngx.log(ngx.ERR, "Header k v: ", k, v)
        -- ngx.var.access_key = string.gsub(string.gsub(string.match(v, "AWS.*:"),"AWS ", ""),":","")
        ngx.var.access_key = string.match(v, "AWS (.*):")
        if not ngx.var.access_key then
          for word in string.gmatch(string.match(v, "Credential=(.*)/"),"([%a,%d,--,_]+)/") do ngx.var.access_key = word break end
          -- ngx.var.access_key = string.match(v, "Credential=(.*)/")
        end
      end
    end
    local rh = ngx.resp.get_headers()
    for k, v in pairs(rh) do
      ngx.var.resp_header = ngx.var.resp_header .. k.."="..v.." "
    end

    -- Parser args and S3 Method
    -- ngx.var.s3method = ngx.req.get_method()

    if ngx.req.get_method() == "DELETE" then
       ngx.var.s3method = "DeleteObject"
    end

    --if ngx.req.get_method() == "HEAD" then
    if ngx.var.request_method == "HEAD" then
       ngx.var.s3method = "HeadObject"
    end

    if ngx.req.get_method() == "GET"  then
      if ngx.var.bucket == "" then
        ngx.var.s3method = "ListBuckets"
      end
      local args, err = ngx.req.get_uri_args()
      if not err then
         for key, val in pairs(args) do
             if type(val) == "table" then
                 ngx.var.s3args = ngx.var.s3args .. key..":"..table.concat(val, "; ")..", "
             else
                 ngx.var.s3args = ngx.var.s3args .. key..":"..val..", "
             end
             if key == "list-type" then
               ngx.var.s3method = "ListObjectsV2"
             elseif key == "delimiter" then
               ngx.var.s3method = "ListObjects"
             end
         end
         ngx.var.s3args = "{ " .. ngx.var.s3args .. " }"
      end
      if (ngx.var.s3method == "") then
        local _, count = string.gsub(ngx.var.request_uri, "/", "")
        if (count == 1) then
          if string.find(ngx.var.request_uri, "list%-type") then
            ngx.var.s3method = "ListObjectsV2"
          else
            ngx.var.s3method = "ListObjects"
          end
        elseif count > 1 then
          ngx.var.s3method = "GetObject"
        end
      end
    end

  ';


  set $resp_body "";
  body_filter_by_lua '
    local resp_body = string.sub(ngx.arg[1], 1, 1000)
    ngx.ctx.buffered = (ngx.ctx.buffered or "") .. resp_body
    if ngx.arg[2] then
     ngx.var.resp_body = ngx.ctx.buffered
    end
--    if ngx.req.get_method() == "GET" then
--     local SLAXML = require "slaxdom"
--     ngx.log(ngx.ERR, "Body for parsing: ", ngx.var.resp_body)
--     if ngx.var.resp_body then
--       local doc = SLAXML:dom(ngx.var.resp_body)
--     end
--     ngx.log(ngx.ERR, "Parser result: ", doc)
--    end

    -- Parser args and S3 Method
    if ngx.req.get_method() == "POST" then
      local args, err = ngx.req.get_post_args()
      if not err then
         for key, val in pairs(args) do
             if type(val) == "table" then
                 ngx.var.s3args = ngx.var.s3args .. key..":"..table.concat(val, "; ")..", "
             else
                 ngx.var.s3args = ngx.var.s3args .. key..":"..val..", "
             end
             if key == "list-type" then
               ngx.var.s3method = "ListObjectsV2"
             -- elseif
             --     ngx.var.s3method =
             end
         end
         if string.gsub(ngx.var.s3args, "CompleteMultipartUpload", "") >= "1" then
           ngx.var.s3method = "CompleteMultipartUpload"
         end
         if string.gsub(ngx.var.resp_body, "InitiateMultipartUploadResult", "") >= "1" then
           ngx.var.s3method = "InitiateMultipartUpload"
         end
      end
    end


    if ngx.req.get_method() == "PUT" then
      ngx.var.s3method = "PutObject"
      --if string.find(ngx.var.req_header, "x%-amz%-—Åopy%-source") then
      if string.find(ngx.var.resp_body, "CopyObjectResult") then
           ngx.var.s3method = "CopyObject"
      end
      if string.find(ngx.var.request_uri, "partNumber") then
           ngx.var.s3method = "UploadPart"
      end
      -- local args, err = ngx.req.get_uri_args()
    end

  ';

        #access_log logs/api_logging.log upstream_logging;
        access_log logs/slotsbe_json.log logger-json;
        #access_log  logs/host.access.log  main;

    log_by_lua_block {
      local latency = ngx.var.upstream_response_time or 0
      -- metric_requests:inc(1, {ngx.var.server_name, ngx.var.status})
      metric_requests:inc(1, {ngx.var.bucket, ngx.var.status, ngx.var.access_key, ngx.req.get_method()})
      -- metric_latency:observe(tonumber(ngx.var.request_time), {ngx.var.server_name})
      metric_bytes:inc(tonumber(ngx.var.request_length), {ngx.var.bucket})
      metric_response_sizes:observe(tonumber(ngx.var.bytes_sent))
      -- metric_latency_new:observe(tonumber(ngx.var.request_time), {ngx.var.bucket, ngx.var.status, ngx.var.access_key, ngx.req.get_method()})
    }



        location / {

##Test options for v4
## Extract download url from the request
#set $download_uri $2;
#set $download_host $1;

## Extract the arguments from request.
## That is the Signed URL part that you require to get the file from S3 servers
#if ($download_uri ~* "([^/]*$)" ) {
#    set  $filename  $1;
#}
## Compose download url
#set $download_url $download_host/$download_uri?$args;
## Set download request headers
#proxy_http_version      1.1;
#proxy_set_header        Connection "";
#proxy_hide_header       x-amz-id-2;
#proxy_hide_header       x-amz-request-id;
#proxy_hide_header       Set-Cookie;
#proxy_ignore_headers    "Set-Cookie";
## Activate the proxy buffering, without it limiting bandwidth speed in proxy will not work!
#proxy_buffering on;
## Buffer 512 KB data
#proxy_buffers 32 16k;


            set $target_slot '';
            access_by_lua '
                local http_host = ngx.var.http_host

                if not http_host then
                    ngx.log(ngx.ERR, "no http-host found")
                    return ngx.exit(400)
                end
		-- redis connect obj should be global 
		-- so we can inject it in custom function
		-- over one request context and not creating one in custom functions
                red = redis:new()
                red:set_timeouts(1000, 1000, 1000)
                -- red:set_timeout(1000) -- 1 second

		-- TODO: elpin: may be we can use unix socket here ? We can not because redshisft should be work in slot mod in separate servers
                local ok, err = red:connect("127.0.0.1", 6379)
                if not ok then
                    ngx.log(ngx.ERR, "failed to connect to redis: ", err)
                    return ngx.exit(500)
                end

                -- assigning the dynamic key
                -- local s3user = string.match(ngx.req.get_headers()["authorization"], "AWS (.*):")
                -- if not s3user then
                --  s3user = ""
                -- end
                local s3user = ngx.var.access_key

                local bucket = ""
                for word in string.gmatch(ngx.var.uri,"/([%a,%d,--,_]+)") do bucket = word break end
                -- ngx.var.bucket = ngx.var.realpath_root

		-- REQUESTS LIMITING BY POLICIES
                -- RPS
                local limrps_user_backet_method = "limrps_" .. s3user .. "_" .. bucket .. "_" .. ngx.req.get_method()
                local limrps_backet_method = "limrps_" .. bucket .. "_" .. ngx.req.get_method()
                local limrps_backet = "limrps_" .. bucket
		local limrps_method = "limrps_" .. ngx.req.get_method()

                -- TODO COUNT or THROUTPUT
                keys={limrps_user_backet_method,limrps_backet_method,limrps_backet,limrps_method}
                limiter.validate(red,keys)

		-- ROUTING 
                local r_user_backet_method = "r_" .. s3user .. "_" .. bucket .. "_" .. ngx.req.get_method()
                local r_backet_method = "r_" .. bucket .. "_" .. ngx.req.get_method()
                local r_backet = "r_" .. bucket
		-- Need tests. Potentially not good idea regarding performance degradation
                local r_ro_slot = "r_ro_slot"
                local r_w_slot = "r_w_slot"

                local arr_route = { r_user_backet_method, r_backet_method, r_backet, r_ro_slot, r_w_slot }

                local fPath = ""
                for i = 1, 3 do
                  -- Replace to multiget from redis
                  local res, err = red:get(arr_route[i])
                  if not res then
                    ngx.log(ngx.ERR, "No HMGET: ", err, arr_route[i])
                  else
                    fPath = res
                    ngx.log(ngx.ERR, "arr_val: ", arr_route[i])
                    ngx.log(ngx.ERR, "fPath founded: ", fPath)
                    break
                  end
                end

                if not fPath then
                  if ngx.req.get_method() == "GET" then
                    fPath = "http://read_slot"
                  else
                    fPath = "http://write_slot"
                  end
                end

                red:set_keepalive()

                ngx.var.target_slot = fPath
                ngx.log(ngx.ERR, "Traget slot: ", fPath)
            ';

#            proxy_pass $target_slot;

             proxy_pass http://192.168.222.113:8080/;
             proxy_set_header X-Real-IP $remote_addr;
             proxy_set_header Host $host;
             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
             proxy_set_header X-Forwarded-Proto $scheme;
             #proxy_pass http://ceph-slot2/;
        }

#        location /rwtest {
#
#	    set $myuser '';
#
#	    rewrite_by_lua_block
#	    {
#    		local user=ngx.req.get_header("Auth")
#    		#//code to get the updated value
#    		#//perform some redirection logic on error
#    		local user_encoded = enc(user)
#    		local only_user = string.sub(user_encoded,1,string.find(user_encoded, ":"))
#    		ngx.var.myuser= enc(only_user)
#    		ngx.req.set_header("myheader", user)
#	    }
#	    proxy_pass  "https://127.0.0.1:8080";
#	}


        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    server {
      listen 9145;
      allow 192.168.0.0/16;
      deny all;
      location /metrics {
        content_by_lua_block {
          metric_connections:set(ngx.var.connections_reading, {"reading"})
          metric_connections:set(ngx.var.connections_waiting, {"waiting"})
          metric_connections:set(ngx.var.connections_writing, {"writing"})
          metric_connections:set(ngx.var.connections_active, {"active"})
          prometheus:collect()
        }
      }
    }

    server {
      listen 8001;
#      allow 192.168.0.0/16;
#      deny all;
      location / {
          root /opt/slotsbe-agent/bkp/;
          index index.html;
          autoindex on;
      }
    }

}
